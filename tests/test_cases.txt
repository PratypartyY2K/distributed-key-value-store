Distributed Key-Value Store Manual Test Catalog
===============================================
Purpose
-------
This catalog explains how to exercise and validate every major behavior of the
ABD and BLOCK implementations. Tests are grouped by feature area and follow a
predictable structure (preconditions, commands, expected observations) so they
can be executed manually or automated in shell scripts.

How to use this document
------------------------
* Make sure the binaries in `build/` are up to date.
* Verify the referenced `replicas_N.txt` files point at reachable hosts.
* Run the commands exactly as shown unless the test explicitly says to vary a
  parameter (e.g., the replica count).
* Under “Verification”, capture the noted signals (client output, timestamps,
  log entries) so that regressions can be compared run-over-run.

================================================================================
1. Basic Replica Functionality
================================================================================
Test 1.1 – Single Replica GET/PUT (BLOCK mode)
  Goal: Confirm the raw KV store reads back values when there is only one
  replica (BLOCK and ABD are identical in this configuration).
  Command:
    ./client replicas_1.txt put "hello"
    ./client replicas_1.txt get
  Verification:
    The GET command prints `hello`. Server stderr/stdout should be clean.

Test 1.2 – Single Replica GET/PUT (ABD mode)
  Goal: Validate the ABD code-path on the same single replica to ensure the
  timestamp handling degenerates gracefully.
  Command:
    ./client replicas_1.txt abd_put "alpha"
    ./client replicas_1.txt abd_get
  Verification:
    Output mirrors Test 1.1; quorums trivially succeed with N=1.

================================================================================
2. Multi-Replica Correctness Tests (ABD Only)
================================================================================
Test 2.1 – ABD write propagates timestamp
  Command:
    ./client replicas_3.txt abd_put "v1"
    ./client replicas_3.txt abd_get
  Verification:
    GET returns `v1`. Inspect replica logs to ensure highest timestamp (and
    value) is present everywhere after the implicit read-repair.

Test 2.2 – Sequential writes produce increasing timestamps
  Command:
    ./client replicas_3.txt abd_put "v1"
    ./client replicas_3.txt abd_put "v2"
    ./client replicas_3.txt abd_put "v3"
  Verification:
    Read back `v3`. Replica logs show monotonically increasing timestamps.

Test 2.3 – Read-repair validates linearizability
  Setup:
    Pause one replica (SIGSTOP) or kill it prior to issuing the GET below.
  Command:
    ./client replicas_3.txt abd_put "correct_value"
    ./client replicas_3.txt abd_get
  Verification:
    GET always returns `correct_value`; once the paused replica resumes it
    performs the write-back phase and converges to the same timestamp.

Test 2.4 – ABD read should not return stale values
  Setup:
    Kill a replica using `pkill replica` to simulate a crash.
  Command:
    ./client replicas_3.txt abd_get
  Verification:
    Requests succeed as long as 2/3 replicas respond. Latency should be slightly
    higher due to quorum retries, but values remain correct.

================================================================================
3. Multi-Replica Correctness Tests (BLOCK Protocol)
================================================================================
Test 3.1 – BLOCK PUT blocks until all replicas ACK
  Setup:
    Slow a replica using `tc qdisc add dev eth0 root netem delay 200ms`.
  Command:
    ./client replicas_3.txt put "xyz"
  Verification:
    Observe PUT latency climb by the injected delay (~200 ms) confirming the
    blocking behavior.

Test 3.2 – BLOCK GET may return stale value
  Command:
    ./client replicas_3.txt put "new_value"
    # Kill replica 1 before it is updated.
    ./client replicas_3.txt get
  Verification:
    Depending on which replica answers, GET yields either the new or old value.
    Record both outcomes to demonstrate weaker consistency guarantees.

================================================================================
4. Concurrency Tests
================================================================================
Test 4.1 – Concurrent writes (BLOCK mode)
  Command:
    # Terminal A
    ./client replicas_3.txt put "A"
    # Terminal B
    ./client replicas_3.txt put "B"
  Verification:
    Different replicas may converge to different values. Document the final GET
    outputs per replica to show lack of conflict resolution.

Test 4.2 – Concurrent writes (ABD mode)
  Command:
    # Terminal A
    ./client replicas_3.txt abd_put "A"
    # Terminal B
    ./client replicas_3.txt abd_put "B"
  Verification:
    After both complete, all GETs eventually return whichever value carried the
    higher timestamp. Replica logs show repaired timestamps after read phase.

================================================================================
5. Load Testing
================================================================================
Test 5.1 – Load test sanity
  Command:
    ./client replicas_3.txt load 4 0.9 5 abd
  Verification:
    Total ops > 1000, throughput non-zero, GET latency strictly lower than PUT.
    Store the stdout file under `raw_logs/` for parser ingestion.

Test 5.2 – N scaling test
  Command:
    ./client replicas_1.txt load 8 0.9 5 block
    ./client replicas_3.txt load 8 0.9 5 block
    ./client replicas_5.txt load 8 0.9 5 block
  Verification:
    Throughput drops as N increases; PUT latency rises because BLOCK writes to
    every replica. Capture throughput table as evidence.

================================================================================
6. Crash Tolerance Tests
================================================================================
Test 6.1 – Client crash experiment (ABD)
  Command:
    ./run_client_crash_experiment.sh abd 0.9 3 16
  Verification:
    Controller log shows client 1 termination at t≈10 s while others continue.
    Resulting folder: `crash_exp_abd_N3_ratio0.9_*` contains survivor logs plus
    an empty file for the crashed client.

Test 6.2 – Client crash experiment (BLOCK)
  Command:
    ./run_client_crash_experiment.sh block 0.1 5 16
  Verification:
    Throughput stabilizes quickly for BLOCK; ABD counterpart (for comparison)
    exhibits higher post-crash latency spikes. Archive stdout in crash_logs.

================================================================================
7. Fault Recovery Tests
================================================================================
Test 7.1 – Replica restart (ABD)
  Command:
    pkill replica
    ./replica 0.0.0.0:50051
    ./client replicas_3.txt abd_get
  Verification:
    After restart the read-repair path repopulates state on the new process.
    Confirm via replica logs that timestamps catch up immediately.

================================================================================
8. Invalid Input / Edge Cases
================================================================================
Test 8.1 – Empty PUT
  Command:
    ./client replicas_3.txt put ""
  Verification:
    Server stores an empty string; subsequent GET returns nothing but still
    reports HTTP/gRPC success.

Test 8.2 – Invalid mode
  Command:
    ./client replicas_3.txt load 4 0.9 5 invalid_mode
  Verification:
    Client prints a friendly usage/error message and exits gracefully.

Test 8.3 – Missing file
  Command:
    ./client missing.txt get
  Verification:
    Tool emits `No replicas.` then exits without crashing.

================================================================================
9. Cleanup Verification
================================================================================
Test 9.1 – All logs generated correctly
  Command:
    ls crash_logs/
  Verification:
    Expect folders for each (mode, N, ratio) combination. Every directory
    contains three files; the intentionally crashed client log is empty,
    confirming the kill signal landed.
